#include "front.h"
#include <stdio.h>
#include <ctype.h>

//RUN CODE BY TYPING gcc lexparse.c front.c parser
// then do parser.exe

void assign();
void expr();
void term();
void factor();
void exp();


/******************************************************/
/* main driver */
int main()
{
    /* Open the input data file and process its contents */
    if ((in_fp = fopen("front.in", "r")) == NULL)
        printf("ERROR - cannot open front.in \n");
    else
    {
        getChar();
        do
        {
            lex();
            assign(); //given that symbol, the syntax analyser will now check the provided grammar and try to build a syntax tree

        } while (nextToken != EOF);
    }
}

/* assign
Parses strings in the language generated by the rule:
<assign> -> {{unsigned|signed}(byte|short|int|long)}<ident>(=|+=|-=|*=|/=|%=) <expr>
*/
void assign()
{
    printf("Enter <assign>\n");
    //if the start of the front.in is an identifier = <expr>
    if(nextToken == IDENT)
    {
        //get the next token
        lex();

        if(nextToken == ASSIGN_OP || nextToken == PLUSEQUALS || nextToken == MINUSEQUALS || nextToken == MULTEQUALS || nextToken == DIVIDEEQUALS || nextToken == MODEQUALS)
        {
            lex();
            expr();
        }
        else{
            expr();
        }
    }
    else{
        expr();
    }

}


/* expr
Parses strings in the language generated by the rule:
<expr> -> <term> {(+ | -) <term>}
*/
void expr()
{
    printf("Enter <expr>\n");
    /* Parse the first term */
    term();
    /* As long as the next token is + or -, get
    the next token and parse the next term */
    while (nextToken == ADD_OP || nextToken == SUB_OP)
    {
        lex();
        term();
    }
    printf("Exit <expr>\n");
} /* End of function expr */

/* term
Parses strings in the language generated by the rule:
<term> -> <factor> {(* | /) <factor>)
*/
void term()
{
    printf("Enter <term>\n");
    /* Parse the first factor */
    factor();
    /* As long as the next token is * or /, get the
    next token and parse the next factor */
    while (nextToken == MULT_OP || nextToken == DIV_OP || nextToken == MOD_OP)
    {
        lex();
        factor();
    }
    printf("Exit <term>\n");
} /* End of function term */



void factor()
{
    printf("Enter <factor>\n");
    /*Parse the first exp*/
    exp();
    /* As long as the next token is a ^ we get the next token and parse the next exp*/
    while(nextToken == POW_OP)
    {
        lex();
        exp();
    }
    printf("Exit <factor>\n");
}


/* factor
Parses strings in the language generated by the rule:
<factor> -> id | int_constant | ( <expr )
*/
void exp()
{
    printf("Enter <exp>\n");
    /* Determine which RHS */
    if (nextToken == IDENT || nextToken == INT_LIT)

        /* Get the next token */
        lex();
    /* If the RHS is ( <expr> ), call lex to pass over the
    left parenthesis, call expr, and check for the right
    parenthesis */
    else
    {
        if (nextToken == LEFT_PAREN)
        {
            lex();
            expr();
            if (nextToken == RIGHT_PAREN)
                lex();
            else
                perror("Error occured");
        } /* End of if (nextToken == ... */
        /* It was not an id, an integer literal, or a left
        parenthesis */
        else
            perror("Error occured");
    } /* End of else */
    printf("Exit <exp>\n");
    ;
} /* End of function exp */



