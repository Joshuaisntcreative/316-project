#include "front.h"
#include <stdio.h>
#include <ctype.h>

void expr();
void term();
void factor();

/******************************************************/
/* main driver */
int main()
{
    /* Open the input data file and process its contents */
    if ((in_fp = fopen("front.in", "r")) == NULL)
        printf("ERROR - cannot open front.in \n");
    else
    {
        getChar();
        do
        {
            lex(); //syntax analyser will call the get next token, this can be a "(, x, ), ="... its the symbol itself,
            expr(); //given that symbol, the syntax analyser will now check the provided grammar and try to build a syntax tree
        } while (nextToken != EOF);
    }
}

/* assign
Parses strings in the language generated by the rule:
<assign> -> {{unsigned|signed}(byte|short|int|long)}<ident>(=|+=|-=|*=|/=|%=) <expr>
*/

void assign()
{
    printf("Enter assign\n");
    
}


/* expr
Parses strings in the language generated by the rule:
<expr> -> <term> {(+ | -) <term>}
*/
void expr()
{
    printf("Enter <expr>\n");
    /* Parse the first term */
    term();
    /* As long as the next token is + or -, get
    the next token and parse the next term */
    while (nextToken == ADD_OP || nextToken == SUB_OP)
    {
        lex();
        term();
    }
    printf("Exit <expr>\n");
} /* End of function expr */

/* term
Parses strings in the language generated by the rule:
<term> -> <factor> {(* | /) <factor>)
*/
void term()
{
    printf("Enter <term>\n");
    /* Parse the first factor */
    factor();
    /* As long as the next token is * or /, get the
    next token and parse the next factor */
    while (nextToken == MULT_OP || nextToken == DIV_OP)
    {
        lex();
        factor();
    }
    printf("Exit <term>\n");
} /* End of function term */

/* factor
Parses strings in the language generated by the rule:
<factor> -> id | int_constant | ( <expr )
*/
void factor()
{
    printf("Enter <factor>\n");
    /* Determine which RHS */
    if (nextToken == IDENT || nextToken == INT_LIT)

        /* Get the next token */
        lex();
    /* If the RHS is ( <expr> ), call lex to pass over the
    left parenthesis, call expr, and check for the right
    parenthesis */
    else
    {
        if (nextToken == LEFT_PAREN)
        {
            lex();
            expr();
            if (nextToken == RIGHT_PAREN)
                lex();
            else
                perror("Error occured");
        } /* End of if (nextToken == ... */
        /* It was not an id, an integer literal, or a left
        parenthesis */
        else
            perror("Error occured");
    } /* End of else */
    printf("Exit <factor>\n");
    ;
} /* End of function factor */



