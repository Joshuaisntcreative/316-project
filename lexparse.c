#include "front.h"
#include <stdio.h>
#include <ctype.h>
#include <string.h>
//RUN CODE BY TYPING gcc lexparse.c front.c parser.exe
// then do parser.exe

void assign();
void expr();
void term();
void factor();
void exp3();
int depth = 0;


/******************************************************/
/* main driver */
int main()
{
    /* Open the input data file and process its contents */
    if ((in_fp = fopen("front.in", "r")) == NULL)
        printf("ERROR - cannot open front.in \n");
    else
    {
        getChar();
        do
        {
            lex();
            assign(); //given that symbol, the syntax analyser will now check the provided grammar and try to build a syntax tree

        } while (nextToken != EOF);
    }
}

/* assign
Parses strings in the language generated by the rule:
<assign> -> {{unsigned|signed}(byte|short|int|long)}<ident>(=|+=|-=|*=|/=|%=) <expr>
*/
void assign()
{
    printf("Enter <assign>\n");
    //if the start of the front.in is an IDENT = <expr>, to show optional {unsigned|signed} we can run a while loop if the 
    if(nextToken == IDENT || nextToken == INT_KEYWORD || nextToken == UNSIGNED_KEYWORD || nextToken == SIGNED_KEYWORD || nextToken == SHORT_KEYWORD || nextToken == LONG_KEYWORD)
    {
        //get the next token
        lex();
        //the assignment supports the {unsigned|signed}(byte|short|int|long)} but doesn't change the lexical analyser functionality, by support, means that the lexical analyser recognizes that the keywords and incremental operators are there and will continue with our regular grammar rules.
        //by extension, the assignment will compute the next character by calling lex and then go into expr from our grammar rules  
        if(nextToken == ASSIGN_OP || nextToken == PLUSEQUALS || nextToken == MINUSEQUALS || nextToken == MULTEQUALS || nextToken == DIVIDEEQUALS || nextToken == MODEQUALS)
        {
            lex();
            expr();
        }
        else{
            expr();
        }
    }
    else{
        //then there isn't an equal sign and the front.in line, houses just an expression.
        expr();
    }

}


/* expr
Parses strings in the language generated by the rule:
<expr> -> <term> {(+ | -) <term>}
*/
void expr()
{
    depth++;
    printf("Enter %d <expr>\n", depth);
    /* Parse the first term */
    term();
    /* As long as the next token is + or -, get
    the next token and parse the next term */
    while (nextToken == ADD_OP || nextToken == SUB_OP)
    {
        lex();
        term();
    }
    printf("Exit %d <expr>\n", depth);
    depth--;
} /* End of function expr */

/* term
Parses strings in the language generated by the rule:
<term> -> <factor> {(* | /) <factor>)
*/
void term()
{
    depth++;
    printf("Enter %d <term>\n", depth);
    /* Parse the first factor */
    factor();
    /* As long as the next token is * or /, get the
    next token and parse the next factor */
    while (nextToken == MULT_OP || nextToken == DIV_OP || nextToken == MOD_OP)
    {
        lex();
        factor();
    }
    printf("Exit %d <term>\n", depth);
    depth--;
} /* End of function term */



void factor()
{
    depth++;
    printf(" Enter %d <factor>\n", depth);
    /*Parse the first exp*/
    exp3();
    /* As long as the next token is a ^ we get the next token and parse the next exp*/
    while(nextToken == POW_OP)
    {
        lex();
        exp3();
    }
    printf(" Exit %d <factor>\n",depth);
    depth--;
}


/* factor
Parses strings in the language generated by the rule:
<factor> -> id | int_constant | ( <expr )
*/
void exp3()
{
    depth++;
    printf("Enter %d  <exp>\n", depth);

    if (nextToken == IDENT || nextToken == INT_LIT)
    {
        lex();
    }
    else if (nextToken == LEFT_PAREN)
    {
        lex();          // consume '('
        expr();         // parse the inner expression
        if (nextToken == RIGHT_PAREN)
            lex();      // consume ')'
        else
            printf("ERROR: missing ')'\n");
    }
    else if (nextToken == RIGHT_PAREN)
    {
        
        // just return gracefully â€” don't treat as error
        // this handles redundant exp3() calls that hit a closing paren
    }
    else
    {
        printf("ERROR: unexpected token %d\n", nextToken);
    }

    printf(" Exit %d <exp>\n", depth);
    depth--;
}