#include "front.h"
#include <stdio.h>
#include <ctype.h>
#include <string.h>
//RUN CODE BY TYPING gcc lexparse.c front.c parser.exe
// then do parser.exe

void assign();
void expr();
void term();
void factor();
void exp();


/******************************************************/
/* main driver */
int main()
{
    /* Open the input data file and process its contents */
    if ((in_fp = fopen("front.in", "r")) == NULL)
        printf("ERROR - cannot open front.in \n");
    else
    {
        getChar();
        do
        {
            lex();
            assign(); //given that symbol, the syntax analyser will now check the provided grammar and try to build a syntax tree

        } while (nextToken != EOF);
    }
}

/* assign
Parses strings in the language generated by the rule:
<assign> -> {{unsigned|signed}(byte|short|int|long)}<ident>(=|+=|-=|*=|/=|%=) <expr>
*/
void assign()
{
    printf("Enter <assign>\n");
    //if the start of the front.in is an IDENT = <expr>, to show optional {unsigned|signed} we can run a while loop if the 
    if(nextToken == IDENT || nextToken == INT_KEYWORD || nextToken == UNSIGNED_KEYWORD || nextToken == SIGNED_KEYWORD || nextToken == SHORT_KEYWORD || nextToken == LONG_KEYWORD)
    {
        //get the next token
        lex();
        //the assignment supports the {unsigned|signed}(byte|short|int|long)} but doesn't change the lexical analyser functionality, by support, means that the lexical analyser recognizes that the keywords and incremental operators are there and will continue with our regular grammar rules.
        //by extension, the assignment will compute the next character by calling lex and then go into expr from our grammar rules  
        if(nextToken == ASSIGN_OP || nextToken == PLUSEQUALS || nextToken == MINUSEQUALS || nextToken == MULTEQUALS || nextToken == DIVIDEEQUALS || nextToken == MODEQUALS)
        {
            lex();
            expr();
        }
        else{
            expr();
        }
    }
    else{
        //then there isn't an equal sign and the front.in line, houses just an expression.
        expr();
    }

}


/* expr
Parses strings in the language generated by the rule:
<expr> -> <term> {(+ | -) <term>}
*/
void expr()
{
    printf("Enter <expr>\n");
    /* Parse the first term */
    term();
    /* As long as the next token is + or -, get
    the next token and parse the next term */
    while (nextToken == ADD_OP || nextToken == SUB_OP)
    {
        lex();
        term();
    }
    printf("Exit <expr>\n");
} /* End of function expr */

/* term
Parses strings in the language generated by the rule:
<term> -> <factor> {(* | /) <factor>)
*/
void term()
{
    printf("Enter <term>\n");
    /* Parse the first factor */
    factor();
    /* As long as the next token is * or /, get the
    next token and parse the next factor */
    while (nextToken == MULT_OP || nextToken == DIV_OP || nextToken == MOD_OP)
    {
        lex();
        factor();
    }
    printf("Exit <term>\n");
} /* End of function term */



void factor()
{
    printf("Enter <factor>\n");
    /*Parse the first exp*/
    exp();
    /* As long as the next token is a ^ we get the next token and parse the next exp*/
    while(nextToken == POW_OP)
    {
        lex();
        exp();
    }
    printf("Exit <factor>\n");
}


/* factor
Parses strings in the language generated by the rule:
<factor> -> id | int_constant | ( <expr )
*/
void exp()
{
    printf("Enter <exp>\n");
    /* Determine which RHS */
    if (nextToken == IDENT || nextToken == INT_LIT)

        /* Get the next token */
        lex();
    /* If the RHS is ( <expr> ), call lex to pass over the
    left parenthesis, call expr, and check for the right
    parenthesis */
    else
    {
        if (nextToken == LEFT_PAREN)
        {
            lex();
            expr();
            if (nextToken == RIGHT_PAREN)
                lex();
            else
                perror("Error occured");
        } /* End of if (nextToken == ... */
        /* It was not an id, an integer literal, or a left
        parenthesis */
        else
            perror("Error occured");
    } /* End of else */
    printf("Exit <exp>\n");
    ;
} /* End of function exp */



